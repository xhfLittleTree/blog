---
title: parcel
date: 2024-01-02 09:41:00
permalink: /pages/20240102094100/
categories: 
  - 学习
tags: 
  - null
---

## 背景介绍

项目中使用了parcel进行页面的挂载

1. parcel是什么

Parcels是single-spa的一个高级特性。一个single-spa 的 parcel，指的是一个与框架无关的组件，由一系列功能构成，可以被应用手动挂载，无需担心由哪种框架实现。[Pacels文档](https://zh-hans.single-spa.js.org/docs/parcels-overview/ "Pacels文档")

2. 如何使用parcel

Parcels有3个必填生命周期函数(bootstrap， mount 和 unmount)和1个可选生命周期函数(update)

以下为官网中给出的使用样例：

```js
// parcel 的实现
const parcelConfig = {
  bootstrap() {
    // 初始化
    return Promise.resolve()
  },
  mount() {
    // 使用某个框架来创建和初始化dom
    return Promise.resolve()
  },
  unmount() {
    // 使用某个框架卸载dom，做其他的清理工作
    return Promise.resolve()
  }
}
// 如何挂载parcel
const domElement = document.getElementById('place-in-dom-to-mount-parcel')
const parcelProps = {
  domElement, customProp1: 'foo'
}
const parcel = singleSpa.mountRootParcel(parcelConfig, parcelProps)
// parcel 被挂载，在mountPromise中结束挂载
parcel.mountPromise.then(() => {
  console.log('finished mounting parcel!')
  // 如果我们想重新渲染parcel，可以调用update生命周期方法，其返回值是一个 promise
  parcelProps.customProp1 = 'bar'
  return parcel.update(parcelProps)
})
.then(() => {
  // 在此处调用unmount生命周期方法来卸载parcel. 返回promise
  return parcel.unmount()
})
```

[Pacels API](https://zh-hans.single-spa.js.org/docs/parcels-api"Pacels API")

single-spa 对外暴露了两套parcels相关接口。二者的区别主要在于调用者和调用接口的方式。

|       |mountRootParcel	|mountParcel|
|-------| --------------| ----------|
|上下文	| singleSpa	| application|
卸载条件 | 手动卸载	| 手动卸载 + 应用被卸载时|
api位置 | singleSpa 命名导出| 生命周期属性中提供|

通常建议使用mountParcelAPI。mountParcel允许你将parcel在应用里当做一个普通组件处理，不需要考虑parcel由哪个框架实现，也不需要强制调用unmount()方法卸载parcel

对以上两个方法的个人理解：
mountRootParcel 是挂载在主应用上的，当parcel不需要是要手动去卸载，而mountParcel是挂载在子应用上的，当子应用被卸载时，parcel也一起被卸载了

mountRootParcel时singleSpa导出的 
```js
import * as singleSpa from 'single-spa';
singleSpa.mountRootParcel(parcelConfig, parcelProps)
```

为了能够绑定在应用的上下文中，mountParcel会作为生命周期属性进行传入。在子应用的生命周期的参数中可以获取到mountParcel

```js
export const bootstrap = [
  (props) => {
    mountParcel = props.mountParcel
    return Promise.resolve()
  },
  // 其他更多boostrap
]

```

parcel挂载方法有两个参数`parcelConfig` 和 `parcelProps`。

`parcelConfig` 里面声明parcel的生命周期  
`parcelProps` 里面的`domElement`是parcel挂载的元素，另外可以传递一些parcel需要的参数

一个parcel对象包含下面的方法：
`mount`：parcel.unmount() 返回一个promise，当parcel卸载成功后resolve。promise可能会抛出异常，需进行处理。  
`unmount`：parcel.unmount() 返回一个promise，当parcel卸载成功后resolve。promise可能会抛出异常，需进行处理。  
`update`：parcel.update(props) 允许你改变传给parcel的参数。注意不是所有的parcel都支持update方法。  
`getStatus`：parcel.getStatus() 返回一个字符串代表parcel的状态。所有状态如下：

`NOT_BOOTSTRAPPED`: 未初始化  
`BOOTSTRAPPING`: 初始化中  
`NOT_MOUNTED`: 完成初始化，未挂载  
`MOUNTED`: 激活状态，且已挂载至DOM  
`UNMOUNTING`: 卸载中  
`UPDATING`: 更新中  
`SKIP_BECAUSE_BROKEN`: 在初始化、挂载、卸载或更新时发生异常。其他parcel可能会被正常使用，但当前parcel会被跳过。  
`loadPromise`：parcel.loadPromise() 返回一个promise，当parcel被装载(loaded)后resolve。  
`bootstrapPromise`：parcel.bootstrapPromise() 返回一个promise，当parcel初始化后resolve。  
`mountPromise`：parcel.mountPromise() 返回一个promise，当parcel加载后resolve。通常用于检测parcel生成的DOM是否已经挂载。  
`unmountPromise`：parcel.unmountPromise() 返回一个promise，当parcel卸载后resolve。


## 项目中的使用

在子应用的mount生命周期中，获取mountParcel将其挂载到子应用的window上

```js
export function mount(props: any) {
  return new Promise((resolve, reject) => {
    window.parcel = {
      mountParcel: props.mountParcel
    }
    try {
      run() // 时间过长会导致超时
      resolve(null)
    } catch (err) {
      reject(err)
    }
  })
}
```

因为项目是vue框架，所以在parcel的mount生命周期中使用new Vue去挂载画面




