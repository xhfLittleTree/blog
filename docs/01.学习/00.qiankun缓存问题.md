---
title: qiankun缓存问题
date: 2023-09-12 16:05:00
permalink: /pages/20230912160500/
categories:
  - 学习
tags:
  - null
---

## 遇到问题

最近的项目中使用到了 qiankun 框架,由于业务的需求,在项目加载过程中,使用了动态创建 script 标签去加载某些资源的方式

```js
let script = document.createElement('script')
script.src = url // 传入的URL
document.head.appendChild(script)
```

当服务端的资源更新时,在页面不刷新的情况下,再去加载资源的时候,发现虽然依旧走了创建 script 标签去加载资源的方法，但是资源没有更新

## 排查原因

由于使用的 qiankun 框架,qiankun 重写了 HTMLHeadElement 的 appendChild 方法,从而导致我们动态加载资源的方法被 qiankun 拦截了

qiankun 源码:

```js
HTMLHeadElement.prototype.appendChild = getOverwrittenAppendChildOrInsertBefore(
  {
    rawDOMAppendOrInsertBefore: rawHeadAppendChild,
    containerConfigGetter: containerConfigGetter,
    isInvokedByMicroApp: isInvokedByMicroApp,
    target: 'head',
  }
)
```

qiankun 在加载资源的时候会使用缓存,通过动态加载的资源都会被缓存

```js
  var scriptCache = {};
  var fetchScript = function fetchScript(scriptUrl) {
    return scriptCache[scriptUrl] || (scriptCache[scriptUrl] = fetch(scriptUrl).then(function (response) {
      if (response.status >= 400) {
        errorCallback();
        throw new Error("".concat(scriptUrl, " load failed with status ").concat(response.status));
      }
      return response.text();
    })["catch"](function (e) {
      errorCallback();
      throw e;
    }));
  };

  // 不仅是加载的资源文本有缓存,把执行的文本封成的立即执行函数也有缓存
  var evalCache = {};
  function evalCode(scriptSrc, code) {
  var key = scriptSrc;

  if (!evalCache[key]) {
    var functionWrappedCode = "(function(){".concat(code, "})");
    evalCache[key] = (0, eval)(functionWrappedCode);
  }

  var evalFunc = evalCache[key];
  evalFunc.call(window);
```

所以当我们再次加载资源的时候,qiankun 返回的是缓存中的老资源

## 解决方法

### 1. 加载资源的时候使用时间戳

通过 script 标签加载资源的时候使用时间戳,让 qiankun 不再使用缓存

```js
let script = document.createElement('script')
script.src = `${url}?${new Date().getTime()}`
document.head.appendChild(script)
```

这样的问题是每次 qiankun 都会缓存新的资源,导致内存不断增大,有风险

### 2. 加载资源前将 qiankun 的缓存清除

在加载资源前判断 qiankun 中时候有缓存,有的话先清除再加载

修改 qiankun 中引用的 import-html-entry 的包的源码

首先将 scriptCache 和 evalCache 挂载到 window 上

```js
window.scriptCache = window.scriptCache || scriptCache
window.evalCache = window.evalCache || evalCache
```

然后在加载资源前先判断缓存是否存在

```js
//解码的原因是qiankun中的中文路径缓存时会编码
url = encodeURI(url)
if (window.scriptCache && window.evalCache) {
  Object.keys(window.scriptCache).forEach((item) => {
    if (item.includes(url)) {
      delete window.scriptCache[item]
      delete window.evalCache[item]
    }
  })
}
```
这样的话所有的文件都不会走缓存了,但是有时我们并不需要所有的文件都重新加载，只需要一些文件重新加载,减少请求次数时,我们可以去增加配置,在清除缓存前去做些判断和处理
